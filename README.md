# 目录
- [目录](#目录)
- [概述](#概述)
- [目的](#目的)
  - [综述](#综述)
  - [例子](#例子)
  - [结论](#结论)
- [编程语法](#编程语法)
  - [概述](#概述-1)
  - [基本数据类型](#基本数据类型)
    - [整数](#整数)
    - [布尔值](#布尔值)
    - [浮点数](#浮点数)
    - [字符串](#字符串)
  - [逻辑运算](#逻辑运算)
  - [常规数学计算](#常规数学计算)
  - [比较运算](#比较运算)
  - [字符串运算](#字符串运算)
  - [解析目标选择器](#解析目标选择器)
    - [概述](#概述-2)
    - [示例一](#示例一)
    - [示例二](#示例二)
    - [示例三](#示例三)
    - [示例四](#示例四)
    - [示例五](#示例五)
    - [示例六](#示例六)
  - [获取分数](#获取分数)
    - [概述](#概述-3)
    - [示例一](#示例一-1)
    - [示例二](#示例二-1)
    - [示例三](#示例三-1)
  - [执行命令](#执行命令)
    - [示例一](#示例一-2)
    - [示例二](#示例二-2)
  - [引用玩家对表单的响应](#引用玩家对表单的响应)
    - [概述](#概述-4)
    - [模态表单](#模态表单)
    - [长表单](#长表单)
    - [信息表单](#信息表单)
  - [调用函数](#调用函数)
    - [示例一](#示例一-3)
    - [示例二](#示例二-3)
    - [示例三](#示例三-2)
    - [示例四](#示例四-1)
    - [小提示](#小提示)
  - [表达式](#表达式)
    - [示例一](#示例一-4)
    - [示例二](#示例二-4)
    - [示例三](#示例三-3)
    - [示例四](#示例四-2)
    - [示例五](#示例五-1)
    - [示例六](#示例六-1)
    - [示例七](#示例七)
    - [示例八](#示例八)
    - [示例九](#示例九)
    - [示例十](#示例十)
    - [示例十一](#示例十一)
  - [括号](#括号)
    - [示例一](#示例一-5)
    - [示例二](#示例二-5)
    - [示例三](#示例三-4)







# 概述
**Form Python AST** 是基于纯 **Python** 开发的 **AST** 抽象语法树解析器。<br/>
它在形式上定义了一种新的编程语言，并提供了相应的源代码解析、编译和运行的功能。







# 目的
## 综述
在 **Minecraft** 基岩版中，人们通过[文本组件](https://zh.minecraft.wiki/w/%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6#%E5%9F%BA%E5%B2%A9%E7%89%88)来显示标题文本和聊天栏信息。<br/>
文本组件是由 `rawtext` 包裹的列表，目前被广泛用于 `titleraw` 和 `tellraw` 命令。

在基岩版中，文本组件可以用于翻译本地化键名、解析实体名和分数。<br/>
在实践中，它也具有一定的条件判断功能，从而使得单命令方块彩虹条等实践成为现实。

然而，原有的条件判断不是被特别设计的，它更像是一个特性。<br/>
因此，通过利用该特性来处理文本显示实际上并不方便。

具体来说，文本组件在单个条件判断的块中，它只能支持有限次条件测试。<br/>
对于更多的条件测试，则必须通过嵌套文本组件，或展平（平铺）多个条件判断块。





## 例子
例如，下方的这个文本组件用于补全分数的前导零，<br>
并且只会处理具有标签 **square:helper** 的实体。

保证该实体只有 `1` 个，并且其在 `square` 上的分数是非负整数。<br/>
那么，它会这样处理该实体在 `square` 的分数，然后把处理的结果给显示出来。
- 233333 => 233333
- 23333 => 023333
- 2333 => 002333
- 233 => 000233
- 23 => 000023
- 2 => 000002

下面是对应的 **JSON** 文本组件。
```json
{
    "translate": "%%5",
    "with": {
        "rawtext": [
            {
                "selector": "@e[tag=square:helper,scores={square=10000..99999}]"
            },
            {
                "selector": "@e[tag=square:helper,scores={square=!..999,square=!100000..}]"
            },
            {
                "selector": "@e[tag=square:helper,scores={square=!..99,square=!100000..}]"
            },
            {
                "selector": "@e[tag=square:helper,scores={square=..999999}]"
            },
            {
                "rawtext": [
                    {
                        "text": "0"
                    },
                    {
                        "score": {
                            "objective": "square",
                            "name": "@e[tag=square:helper]"
                        }
                    }
                ]
            },
            {
                "rawtext": [
                    {
                        "text": "00"
                    },
                    {
                        "score": {
                            "objective": "square",
                            "name": "@e[tag=square:helper]"
                        }
                    }
                ]
            },
            {
                "rawtext": [
                    {
                        "text": "000"
                    },
                    {
                        "score": {
                            "objective": "square",
                            "name": "@e[tag=square:helper]"
                        }
                    }
                ]
            },
            {
                "translate": "%%3",
                "with": {
                    "rawtext": [
                        {
                            "selector": "@e[tag=square:helper,scores={square=10..99}]"
                        },
                        {
                            "selector": "@e[tag=square:helper,scores={square=1..99}]"
                        },
                        {
                            "rawtext": [
                                {
                                    "text": "0000"
                                },
                                {
                                    "score": {
                                        "objective": "square",
                                        "name": "@e[tag=square:helper]"
                                    }
                                }
                            ]
                        },
                        {
                            "rawtext": [
                                {
                                    "text": "00000"
                                },
                                {
                                    "score": {
                                        "objective": "square",
                                        "name": "@e[tag=square:helper]"
                                    }
                                }
                            ]
                        },
                        {
                            "rawtext": [
                                {
                                    "score": {
                                        "objective": "square",
                                        "name": "@e[tag=square:helper]"
                                    }
                                }
                            ]
                        }
                    ]
                }
            }
        ]
    }
}
```

很显然这是非常复杂的写法，并且非常难以阅读。<br/>
然而，上面的逻辑实际上可以被简化为这样的伪代码。

```python
if {func, game.has_tag('@s', 'square:helper')}:
    number = {score, '@s', 'square'}
    if number >= 100000:
        return str(number)
    elif number >= 10000:
        return '0' + str(number)
    elif number >= 1000:
        return '00' + str(number)
    elif number >= 100:
        return '000' + str(number)
    elif number >= 10:
        return '0000' + str(number)
    elif number >= 1:
        return '00000' + str(number)
    fi
fi

return '000000'
```

另外，如果你有一些数学头脑，<br/>
那么它还可以被继续简化为下面的形式。
```python
if {func, game.has_tag('@s', 'square:helper')}:
    number = {score, '@s', 'square'}
    if number > 0:
        log_ans = {func, math.log(number, 10)}
        log_ans = int(log_ans)
        return '0'*(5-log_ans) + str(number)
    fi
fi

return '000000'
```





## 结论
基于上面给出的例子，我们可以很明显的看出文本组件的局限性。<br/>
因此，本项目希望提供一种方式，摆脱文本组件的复杂写法。<br/>
即，通过提供一种具备可编程性的编程语言来替代原生的文本组件。







# 编程语法
## 概述
目前支持的数据类型如下。
- 整数
- 布尔值
- 浮点数
- 字符串

目前支持的基本操作如下。
- 表达式求值
- 变量赋值
- 代码返回值

支持的代码块分别如下。
- 条件代码块
- 循环代码块





## 基本数据类型
### 整数
诸如 `1, 2, 3` 等不带有小数点的数字。



### 布尔值
表示真或假（是或否）两种状态的数据。<br/>
真（是）采用 `True` 表示，<br/>
假（否）采用 `False` 表示。



### 浮点数
区别于整数，浮点数指代那些具有小数点的数字，也就是小数。<br/>
例如 `2.3, 5.20, 1.0, 2.00000` 等。



### 字符串
由各种文字和符号按顺序组合的串，并且用单引号 `'` 进行包裹。<br/>

下面给出了一些字符串的示例。
- `'你好'`
- `'1+1=2 √'`
- `'你今天吃早饭了吗?'`

如果不使用单引号包裹字符串，则可能会被视为整数或浮点数。<br/>
例如 `2` 会被视为整数 2。只有 `'2'` 才会被视为字符串的 2。

字符串内允许使用转义符号。<br/>
例如，如果希望在字符串内使用单引号，可以考虑使用这样的写法。<br/>
```python
'你好, 你知道 \'Peter\' 叫什么吗？'
```
这种写法等价于下面的形式。
```python
你好, 你知道 'Peter' 叫什么吗？
```

应特别说明的是，诸如 `\u000A` 的形式在现阶段不支持被转义。<br/>
目前仅支持对反斜杠后的 `1` 个字符进行转义。

下面列出了目前支持的转义规则。
| 转义符 | 用法 | 使用后得到的字符 |
| ------ | ---- | ---------------- |
| n      | \n   | 换行             |
| \      | \\\\ | 反斜杠 `\`       |
| '      | \\'  | 单引号 `'`       |
| "      | \\"  | 双引号 `"`       |

在本编程语言中，只有单引号 `'` 包围的字符被视作字符串。<br/>
但您很可能将源代码写在命令方块中，并用双引号 `"` 包围源代码。<br/>

这是因为，命令方块中的字符串用双引号 `"` 包裹，<br/>
并且命令方块除了换行以外，也基本上遵循上面的转义规则。

因此，上面的 Peter 例子就需要改写为下面的形式。<br/>
在该形式中，整个字符串被外围的双引号包裹。
```python
"'你好, 你知道 \\'Peter\\' 叫什么吗？'"
```
这个写法在被命令方块解析后将得到里层的，由单引号包裹的字符串，<br/>
也就是下面你看到的这个字符串。你可以很容易发现它跟原来的字符串等价。
```python
'你好, 你知道 \'Peter\' 叫什么吗？'
```





## 逻辑运算
逻辑运算用于检验真假。<br/>
下面列出了目前支持的逻辑运算符，相应的示例和解释。<br/>

应注意的是，逻辑运算的结果是个布尔值，并且参与逻辑运算的所有事物也应是布尔值。<br/>
如果参与逻辑运算的不是布尔值，而是其他数据类型对应的事物，则运算结果是不确定的。

| 运算符 | 用途         | 示例                  | 解释                                                                                                |
| ------ | ------------ | --------------------- | --------------------------------------------------------------------------------------------------- |
| and    | 与运算       | A and B and ... and N | A、B、...、N 是否同时为真。<br/>如果是这样的，则计算结果为真，否则为假。                            |
| or     | 或运算       | A or B or ... or N    | A、B、...、N 是否有一个为真。<br/>如果是这样的，则计算结果为真，否则为假。                          |
| not    | 取反运算     | not A                 | 布尔值 A 的反转便为计算结果。<br/>这意味着真将变为假，假将变为真。                                  |
| in     | 成员检查运算 | A in B                | 检查 A 是否在 B 中。<br/>如果是这样的，则计算结果为真，否则为假。<br/>如检查 'AB' 是否在 'ABC' 中。 |

特别地，上面的与运算和或运算会在可以断言结果真假时停止处理。<br/>
这意味着如果与运算的过程中，如果已经出现假，则整个运算为假；<br/>
在或运算的过程中，如果已经出现真，则整个运算为真。

另外，上面几个运算符的优先级，从高到低分别如下。
- 成员检查运算 (in)
- 取反运算 (not)
- 与运算 (and)
- 或运算 (or)





## 常规数学计算
数学计算是常规的数学表达式。<br/>
下面是支持的数学运算符及相应的示例和解释。

| 运算符 | 用途   | 示例                | 解释                                                                | 备注                                                          |
| ------ | ------ | ------------------- | ------------------------------------------------------------------- | ------------------------------------------------------------- |
| +      | 加运算 | A + B + C + ... + N | 计算 A 到 N 的和                                                    | 如果 A 到 N 中有一个是浮点数，<br/>则结果为浮点数，否则为整数 |
| -      | 减运算 | A - B - C - ... - N | 计算 A 减去 B，然后再减去 C，<br/>然后一直操作下去直到减去 N 的结果 | 如果 A 到 N 中有一个是浮点数，<br/>则结果为浮点数，否则为整数 |
| *      | 乘运算 | A * B * C * ... * N | 计算 A 乘以 B 乘以 C，<br/>直到乘以 N 的结果                        | 如果 A 到 N 中有一个是浮点数，<br/>则结果为浮点数，否则为整数 |
| /      | 除运算 | A / B / C / ... / N | 计算 A 除以 B，然后再除以 C，<br/>然后一直操作下去直到除以 N 的结果 | 结果一定是浮点数                                              |

上面给出的示例的空格不是必须的，仅是美观用途。<br/>
另外，上面几个运算符的优先级与实际的四则运算的优先级是相同的。





## 比较运算
比较运算可以用于字符串和数字，并且确保所有比较运算的结果都是布尔值。<br/>
下面是目前已经支持的比较运算，以及相应的示例和解释。<br/>
注意，下方给出的示例的空格不是必须的，仅是美观用途。

| 运算符 | 用途               | 示例   | 解释                                                |
| ------ | ------------------ | ------ | --------------------------------------------------- |
| >      | 检查是否大于       | A > B  | 如果 A 大于 B，则计算结果是真，否则是假             |
| <      | 检查是否小于       | A < B  | 如果 A 小于于 B，则计算结果是真，否则是假           |
| >=     | 检查是否大于或等于 | A >= B | 如果 A 大于 B 或 A 等于 B，则计算结果是真，否则是假 |
| <=     | 检查是否小于或等于 | A <= B | 如果 A 小于 B 或 A 等于 B，则计算结果是真，否则为假 |
| ==     | 检查是否等于       | A == B | 如果 A 等于 B，则计算结果是真，否则为假             |
| !=     | 检查是否不等于     | A != B | 如果 A 不等于 B，则计算结果是真，否则为假           |

另外，任何比较运算都不能连用，例如下面的使用方法是错误的。
```python
1 < 10 < 100
```
必须改写为
```python
1 < 10 and 10 < 100
```
在部分情况下，连用比较运算不会产生报错，但它的运算结果是不确定的。





## 字符串运算
字符串也可以参与计算。下面列出了字符串可以使用的运算。<br/>
注意，下方给出的示例的空格不是必须的，仅是美观用途。

| 运算符 | 用途                 | 运算结果 |
| ------ | -------------------- | -------- |
| +      | 拼接一个或多个字符串 | 字符串   |
| *      | 重复字符串本身       | 字符串   |
| ==     | 检查字符串相同       | 布尔值   |
| !=     | 检查字符串不同       | 布尔值   |
| in     | 检查字符串包含       | 布尔值   |
 
| 示例                               | 运算结果     | 解释                                             |
| ---------------------------------- | ------------ | ------------------------------------------------ |
| 'a' + 'b' + 'c'                    | 'abc'        | 将 'a'、'b'、'c' 按顺序拼接到一起                |
| 'ak' * 5                           | 'akakakakak' | 将 'ak' 重复 5 次                                |
| 'aa' == 'ab'                       | False        | 检查 'aa' 和 'ab' 是否相同                       |
| 'ac' != '666'                      | True         | 检查 'ac' 和 '666' 是否不相同                    |
| '吃饭' in '我吃饭了'               | True         | 检查 '吃饭' 是否在 '我吃饭了' 之中               |
| 'ak5' in '我买了一个新的 ak5'      | True         | 检查 'ak5' 是否在 '我买了一个新的 ak5' 之中      |
| '差点没买 ak5' in '我差点买了 ak5' | False        | 检查 '差点没买 ak5' 是否在 '我差点买了 ak5' 之中 |

字符串也可以被比较。这意味着上一章节，即[比较运算](#比较运算)，其中列出的所有运算符也都适用于字符串。<br/>
在技术实现中，我们实际上按顺序比较字符串中的每一个字符，以一种叫做字典序的方式。

受限于篇幅限制，本文档不会详细描述字符串具体是如何比较的。<br/>
这意味着您更被推荐通过执行实际的代码来了解这一切是如何工作的。

一个例子是，由于 `a` 排在 `b, c, d, ..., z` 的前面，<br/>
所以 `a` 开头的所有字符串都一定小于 `b` 到 `z` 开头的所有字符串。





## 解析目标选择器
### 概述
要将目标选择器解析为对应的实体名，使用下方的 **Selector** 语句。<br/>

```
{selector, <target: str>}
```

`<target: str>` 指代一个目标选择器，并且应是一个字符串。<br/>
另外，**Selector** 语句所得的结果亦是一个字符串。

若 `<target: str>` 指示的目标选择器没有与之对应的实体，<br/>
则该语句的执行结果将是一个空的字符串。

若 `<target: str>` 指代多个实体，则这些实体的名字都将被放入执行结果中。<br/>
例如，如果 `<target: str>` 指代的实体是 Steve、Alex 和 233，则该语句的执行结果如下。
```
Steve, Alex, 233
```



### 示例一
解析 `@p` 为实体名。
```python
{selector, '@p'}
```



### 示例二
解析 `@e[type=zombine]` 为实体名。
```python
{selector, '@e[type=zombine]'}
```



### 示例三
解析 `@a[tag=aabbcc,r=3]` 为实体名。
```python
{selector, '@a[tag=aabbcc,r=3]'}
```



### 示例四
解析 `@a[tag=aabbcc,r=3]` 为实体名。
```python
{selector, '@a[tag=aabbcc,r=3]'}
```



### 示例五
解析 `Alex` 为实体名。<br/>
在这个例子中，`Alex` 指代一个名字叫做 `Alex` 的玩家。
```python
{selector, 'Alex'}
```



### 示例六
解析 `@e[name="233"]` 为实体名。
```python
{selector, '@e[name="233"]'}
```





## 获取分数
### 概述
要获取分数，使用下方的 **Score** 语句。

```
{score, <player: str>, <scoreboard: str>}
```

该语句中 `<target: str>` 和 `<scoreboard: str>` 均为字符串。<br/>
但 **Score** 语句的执行结果是一个整数，因为分数只可能是整数。

`<target: str>` 指代指向玩家的目标选择器。<br/>
`<scoreboard: str>` 指代相应分数所在的记分板名。

若想指代命令执行者本身，`<target: str>` 也可以置为通配符 `*`。<br/>
在这种情况下，`<target: str>` 填写为 `@s` 或 `*` 都是等效的。<br/>
最后，若 `<target: str>` 未指向一个玩家，或相应的玩家不存在，则获取到的分数为 0。



### 示例一
获取 `@s` 在记分板 `coin` 的分数。
```python
{score, '@s', 'coin'}
```



### 示例二
获取 `@a[r=10]` 在记分板 `abc` 的分数。
```python
{score, '@a[r=10]', 'abc'}
```



### 示例三
获取 `233` 在记分板 `'cd'` 的分数。<br/>
在这个例子中，`233` 指代一个名字叫做 `233` 的玩家。
```python
{score, '233', '\'cd\''}
```





## 执行命令
要在当前命令执行环境（命令执行上下文）中执行命令，使用下方的 **Command** 语句。

```
{command, <commandLine: str>}
```

该语句中 `<commandLine: str>` 是一个字符串。<br/>
**Command** 语句的执行结果是一个整数，指示命令的成功次数。<br/>
就目前而言，受制于网易接口，成功次数只可能是 0 或 1。

下面给出了一些示例。



### 示例一
在对应的命令执行环境中执行指令 `say hello`。
```python
{command, 'say hello'}
```



### 示例二
在对应的命令执行环境中执行指令 `execute as @s at @s run say hello`。
```python
{command, 'execute as @s at @s run say hello'}
```





## 引用玩家对表单的响应
### 概述
在通过命令方块向玩家展示表单后，玩家可以与表单发生交互，并提交响应。<br/>
因此您需要一个接口来获取玩家针对表单的响应，并根据得到的响应执行对应的处理。



### 模态表单
模态表单由下面列出的元素构成，并且这些元素是有序的。
- 纯文本
- 输入框
- 开关
- 下拉框
- 隐式步进滑块
- 显式步进滑块

玩家可以通过作出下面的操作来填写模态表单。
- 向 `输入框` 填写内容
- 改变 `开关` 开启状态
- 选择 `下拉框` 给出的选项
- 移动 `隐式步进滑块` 或 `显式步进滑块` 中的滑块

玩家填写的内容则会以下面的方式进行存储。<br/>
它们储存的顺序与构成模态表单本身的元素的顺序是一致的。
- 空值 (纯文本)
- 字符串 (输入框)
- 布尔值 (开关)
- 整数 (下拉框)
- 浮点数 (隐式步进滑块)
- 整数 (显式步进滑块)

特别地：
- 对于下拉框和显式步进滑块，`整数` 指的是玩家选中的选项的索引
- 对于隐式步进滑块，`浮点数` 指的是滑块当前最终所在的刻度值

例如，假如我们有这样一个模态表单：
```
纯文本 ABCD、
开关 1（默认关）、
开关 2（默认开）、
隐式步进滑块 1（默认 3.0，最少 1.0，最多 10.0，步长 0.5）、
显式步进滑块 1（内容是 'a', 'b' 和 'c'，默认选择第 2 个）、
输入框 1（默认 'ABC'）
下拉框 1（内容是 '我要吃早饭', '我要吃午饭'，默认选择第 1 个）。
```

则如果用户在不进行任何编辑的情况下，直接提交表单，那么用户的响应如下。
```
空值、
False（关）、
True（开）、
3.0（隐式滑块最终刻度值）、
1（显式滑块最终指向的选项索引）、
'ABC'（用户提供的输入）、
0（下拉框选中的选项的索引）
```

在初步理解模态表单后，您可以通过下面的 **Ref** 语句来获取特定索引上的响应值。

```python
{ref, <dataType: type>, <index: int>}
```

`<index: int>` 指示相应的索引值。<br/>
`<dataType: type>` 指代目标响应值的类型，必须为下列之一。
- int
- bool
- float
- str

具体来说，就上面的例子而言，假设我需要知道 `开关 2` 的结果，<br/>
那么我需要找到 `开关 2` 的位置。它是第三个元素，因此它的索引是 3-1 也就是 2。<br/>
而开关的结果只可能是 `bool`，用 `True` 表示开，用 `False` 表示关。

因此对应的语句如下。
```python
{ref, bool, 2}
```

对于其他部分，对于的语句则如下所示。
```python
开关 1: {ref, bool, 1}
隐式步进滑块 1: {ref, float, 3}
显式步进滑块 1: {ref, int, 4}
输入框 1: {ref, str, 5}
下拉框 1: {ref, int, 6}
```

你不应也无法获取到针对 `纯文本` 的响应。<br/>
因为玩家实际上并不能编辑它们，所以获取它是没有意义的。

另外，如果您填写的数据类型不正确，则会引发错误。<br/>
具体到上面的例子，如果你对 `输入框 1` 使用下面的语句，则将报错。
```python
{ref, bool, 5}
```

这是因为输入框只能输入字符串，<br/>
所以您得到的响应只可能是字符串，而不是布尔值。

这意味着我们实际上会检查获取到的响应值的数据类型是否与您期望的匹配，<br/>
而这么做的目的是为了确保您在编程时减少可能发生的错误。<br/>
这种错误的减少就是通过您手动标注响应值的数据类型进行的。



### 长表单
长表单是由多个按钮组成的，并且这些按钮都是按顺序排列的。<br/>
玩家通过点击长表单中的其中一个按钮来完成对长表单的响应，<br/>
因此玩家对长表单的响应是一个索引，它指向了玩家所点击的按钮。

要获取玩家所点击按钮对应的索引值，使用下面的 **Ref** 语句。
```python
{ref, int, -1}
```

要检查该索引值是否等于 `T`，使用下方的 **Ref** 语句。<br/>
确保下方语句在索引值为 `T` 时返回真，在其他情况下返回假。
```python
{ref, bool, T}
```

与[模态表单](#模态表单)章节所述的一致，上面两个语句中的 `int` 和 `bool` 都指代 `<dataType: type>`。<br/>
对于 `int`，`<dataType: type>` 用于检查 **Ref** 语句执行后所得的结果是否是整数。<br/>
对于 `bool`，`<dataType: type>` 用于检查 **Ref** 语句执行后所得的结果是否是布尔值。



### 信息表单
信息表单用于向玩家显示信息。<br/>
玩家可以通过点击代表“确定”或“取消”的按钮来回应表单。

因此，玩家对信息表单的响应是一个布尔值。<br/>
当布尔值为真时，指示玩家点击指代“确定”的按钮；<br/>
否则，布尔值为假，说明玩家点击了指代“取消”的按钮。

要获取玩家对信息表单的响应，使用下面的 **Ref** 语句。
```python
{ref, bool, -1}
```

要检查玩家点击的是否是代表“确定”的按钮，则使用该语句。<br/>
确保下方语句只在玩家点击了代表“确定”的按钮时返回真，在其他情况下返回假。
```python
{ref, bool, 1}
```

要检查玩家点击的是否是代表“取消”的按钮，则使用该语句。<br/>
确保下方语句只在玩家点击了代表“取消”的按钮时返回真，在其他情况下返回假。
```python
{ref, bool, 0}
```

与[模态表单](#模态表单)章节所述的一致，<br/>
上面三个语句中的 `bool` 都指代 `<dataType: type>`，<br/>
用于检查 **Ref** 语句执行后所得的结果是否是布尔值。





## 调用函数
编程语言的提供者可以为该编程语言的用户提供一些函数。<br/>
然后，用户就可以在代码中调用这些函数，从而执行相应的代码逻辑。<br/>

该编程语言的用户可以通过 **Func** 语句来调用函数。
```python
{func, funcName(arg1, arg2, ..., argN)}
```

`funcName` 指代被调用函数的函数名称，<br/>
应直接写出，而不是用单引号 `'` 包裹。

`arg1, arg2, ..., argN` 是传入函数的多个参数。参数从 `arg1` 到 `argN`。<br/>
应特别注意的是，部分函数可能不要求传入参数，此时就可以不用传入任何参数。<br/>
应注意的是，所有传入函数的参数都必须是本编程语言中存在的数据类型。

如果您不理解上面是 `函数`、`调用函数`、`传入函数的参数` 等词汇，<br/>
可以通过查看下方给出的例子来搞明白它们的意思。



### 示例一
调用名为 `math.sqrt` 的函数，并且只传入参数 `4`。<br/>
该函数将对 4 开平方。开方结果即为该语句的执行结果。
```python
{func, math.sqrt(4)}
```



### 示例二
调用名为 `math.pow` 的函数，并且依次传入参数 `2` 和 `3`。<br/>
该函数将计算 2 的 3 次方的结果。这一计算结果即为该语句的执行结果。
```python
{func, math.pow(2, 3)}
```


### 示例三
调用名为 `get_server_name` 的函数，并且不传入任何参数。<br/>
该函数将获取租赁服的名称。该名称即为该语句的执行结果。
```python
{func, get_server_name()}
```



### 示例四
调用名为 `sum` 的函数，并且依次传入参数 `1`、`3`、`5`、`7` 和 `9`。<br/>
该函数将所有传入的参数加起来。这个相加的结果即为该语句的执行结果。

很显然由于传入的参数是 `1`、`3`、`5`、`7` 和 `9`，<br/>
因此该语句的执行结果是 `1+3+5+7+9=25` 即 `25`。

```python
{func, sum(1, 3, 5, 7, 9)}
```



### 小提示
通过上面给出的几个例子，我们可以发现以下这几点。

我们可以发现函数实际上形如“抽象的机器”。<br/>
也就是说，我们并不需要知道如何实现开平方、求幂次、相加等的实际过程，<br/>
我们只需要“调用函数”，就可以得到开评分、求幂次、相加等的计算结果。

函数会根据你所传入的参数来“做事情”，并把做完后的结果“返回”给函数的调用者。<br/>
比如将 `9` 传入开平方的函数，则将得到 3，然后它就会被返回给调用这个开平方函数的人，于是调用者得到了 3。

需要说明的是，函数可以指代任何“抽象的机器”，<br/>
这其中肯定也包括计算棒棒糖的价格等，以及任何可以被程序计算的事，<br/>
而不仅仅局限于上面给出的几个例子。





## 表达式
表达式是一串求值结果为已支持数据类型之一的单行代码。<br/>
这串单行代码可以包含上面已经提到的所有运算。<br/>
例如，它可以用于数学计算、逻辑判断，或者字符串拼接等。<br/>

执行整个表达式并得到结果，被称为**对表达式进行求值**。<br/>
如果表达式被用于逻辑运算，则最终的求值结果应该是布尔值；<br/>
如果表达式被用于常规数学运算，则最终的求值结果应该是数字；<br/>
如果表达式被用于字符串操作，则最终的求值结果应该是字符串。<br/>

下面列出的例子有助于帮助你的理解。



### 示例一
该表达式将计算 1+1 的结果，很显然是 `2`。<br/>
因此该表达式的求值结果为 `2`。
```python
1+1
```



### 示例二
该表达式将判断 1+1 是否为 2。<br/>
很显然这是成立的，所以求值结果是 `True`。
```python
1+1==2
```



### 示例三
该表达式将判断 1+1=2 并且 2+2=4 是否同时成立。<br/>
很显然这是成立的，所以求值结果是 `True`。
```python
1+1==2 and 2+2==4
```



### 示例四
该表达式将判断 1+1=2 并且 2+2=4 是否同时成立。<br/>
很显然这是成立的，所以求值结果是 `True`。
```python
1+1==2 and 2+2==4
```



### 示例五
该表达式将判断 1+1=2 并且 2+2=4 并且 9+9==0 是否同时成立。<br/>
很显然 9+9 为 18 而不是 0，所以求值结果是 `False`。
```python
1+1==2 and 2+2==4 and 9+9==0 
```



### 示例六
由于与运算（and）的优先级比或运算（or）的更高，<br/>
因此它将先判断 2+2=4 并且 9+9=0 是否成立。<br/>
很显然这是不成立的，所以 `2+2==4 and 9+9==0` 为假。

然后，表达式化为了 `1+1==0 or False`。<br/>
进而化为 `False or False`，因为 1+1 不为 0。

所以，整个表达式的求值结果是假，也就是 `False`。
```python
1+1==0 or 2+2==4 and 9+9==0 
```



### 示例七
它将首先检查 1+1=2 是否正确。<br/>
很显然这是正确的，所以表达式化为 `True or 0/0==0`。

你可以观察到还有一个是 `0/0==0` 即检查 0 除以 0 是否为 0，很显然这是不正确的运算。<br/>
但由于或运算中已经存在一个为真了，所以整个或运算为真。

因此对该表达式的求值结果是 `True`。
```python
1+1==2 or 0/0==0
```

具体来说，在执行表达式时，系统实际是按顺序进行逻辑运算。<br/>
如果在某次运算时，出现了一个真值，则或运算的结果是真，而无论剩余的部分是否正确；<br/>
如果出现的是一个假值，则与运算的结果是假，而无论剩余的部分是否正确。

类似的例子是与运算的，它的求值结果是 `False`。
```python
1+1==0 and 0/0==0
```



### 示例八
该表达式将检查 's' 是否在 'ss' 中。<br/>
很显然这是存在的，因此该表达式的求值结果为 `True`。
```python
's' in 'ss'
```



### 示例九
该表达式将对布尔值 `True` 的值取反，并将取反结果作为该表达式的求值结果。<br/>
对 `True` 取反将得到 `False`，因此该表达式的求值结果为 `False`。
```python
not True
```

同理，对 `False` 取反将得到 `True`。<br/>
因此，下面这个表达式的求值结果为 `True`。
```python
not False
```



### 示例十
该表达式指的是 8 乘以 7 再除以 56 再乘以 24 的结果。<br/>
很显然，该结果为 24，因此该表达式的求值结果为 `24`。
```python
8*7/56*24
```



### 示例十一
```python
    1+1<7   and 6*6>=36 or  not 10!=10  and 4/20>=0 or  'abcd'  in  'aabcdd' and    100>1000
=>  2<7     and 36>=36  or  not False   and 0.2>=0  or  True                 and    False
=>  True    and True    or  True        and True    or  True                 and    False
=>  True                or  True                    or  False
=>  True
```





## 括号
括号可以改变表达式的运算顺序。<br/>
下面给出的一些例子可以帮助理解。



### 示例一
该数学运算先计算 10 乘以 3 的值，然后将乘出来的结果与 1 相加。<br/>
因此，它的结果将是 `31`。
```python
1+(10*3)
```



### 示例二
该表达式先计算 `8*8==60 and 0*0==0` 的值。

很显然 8 乘以 8 是 64，<br/>
所以 `8*8==60 and 0*0==0` 的结果为假。

于是，表达式化为 `4*6/12==2 or False`。<br/>
很显然 4 乘以 6 再除以 12 是 2，所以 `4*6/12==2` 为真。

因此 `4*6/12==2 or False` 即 `True or False` 为真。<br/>
因此，整个表达式的结果是真，也就是 `True`。
```python
4*6/12==2 or (8*8==60 and 0*0==0)
```



### 示例三
```python
    ((9+9>1000  and 7/7==1) and (not    'gbk'   in  'ggbbkk'))  or  (4+4>=8 or  4*7<=1000)
=>  ((18>1000   and 1==1)   and (not    False))                 or  (8>=8   or  28<=1000)
=>  ((False     and True)   and (True))                         or  (True   or  True)
=>  ((False)                and True)                           or  (True)
=>  (False                  and True)                           or  True
=>  (False)                                                     or  True
=>  False                                                       or  True
=>  True
```