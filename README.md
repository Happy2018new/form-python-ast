# Form Python AST
## 目录
- [Form Python AST](#form-python-ast)
  - [目录](#目录)
  - [概述](#概述)
  - [目的](#目的)
    - [综述](#综述)
    - [例子](#例子)
    - [结论](#结论)
  - [编程语法](#编程语法)
    - [概述](#概述-1)
    - [基本数据类型](#基本数据类型)
      - [整数](#整数)
      - [布尔值](#布尔值)
      - [浮点数](#浮点数)
      - [字符串](#字符串)
    - [逻辑运算](#逻辑运算)
    - [数学计算](#数学计算)
    - [括号](#括号)
      - [示例一](#示例一)
      - [示例二](#示例二)
    - [表达式运算](#表达式运算)
      - [示例一](#示例一-1)
      - [示例二](#示例二-1)
      - [示例三](#示例三)
      - [示例四](#示例四)
      - [示例五](#示例五)
      - [示例六](#示例六)
      - [示例七](#示例七)





## 概述
**Form Python AST** 是基于纯 **Python** 开发的 **AST** 抽象语法树解析器。<br/>
它在形式上定义了一种新的编程语言，并提供了相应的源代码解析、编译和运行的功能。



## 目的
### 综述
在 **Minecraft** 基岩版中，人们通过[文本组件](https://zh.minecraft.wiki/w/%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6#%E5%9F%BA%E5%B2%A9%E7%89%88)来显示标题文本和聊天栏信息。<br/>
文本组件是由 `rawtext` 包裹的列表，目前被广泛用于 `titleraw` 和 `tellraw` 命令。

在基岩版中，文本组件可以用于翻译本地化键名、解析实体名和分数。<br/>
在实践中，它也具有一定的条件判断功能，从而使得单命令方块彩虹条等实践成为现实。

然而，原有的条件判断不是被特别设计的，它更像是一个特性。<br/>
因此，通过利用该特性来处理文本显示实际上并不方便。

具体来说，文本组件在单个条件判断的块中，它只能支持有限次条件测试。<br/>
对于更多的条件测试，则必须通过嵌套文本组件，或展平（平铺）多个条件判断块。


### 例子
例如，下方的这个文本组件用于补全分数的前导零，<br>
并且只会处理具有标签 **square:helper** 的实体。

保证该实体只有 `1` 个，并且其在 `square` 上的分数是非负整数。<br/>
那么，它会这样处理该实体在 `square` 的分数，然后把处理的结果给显示出来。
- 233333 => 233333
- 23333 => 023333
- 2333 => 002333
- 233 => 000233
- 23 => 000023
- 2 => 000002

下面是对应的 **JSON** 文本组件。
```json
{
    "translate": "%%5",
    "with": {
        "rawtext": [
            {
                "selector": "@e[tag=square:helper,scores={square=10000..99999}]"
            },
            {
                "selector": "@e[tag=square:helper,scores={square=!..999,square=!100000..}]"
            },
            {
                "selector": "@e[tag=square:helper,scores={square=!..99,square=!100000..}]"
            },
            {
                "selector": "@e[tag=square:helper,scores={square=..999999}]"
            },
            {
                "rawtext": [
                    {
                        "text": "0"
                    },
                    {
                        "score": {
                            "objective": "square",
                            "name": "@e[tag=square:helper]"
                        }
                    }
                ]
            },
            {
                "rawtext": [
                    {
                        "text": "00"
                    },
                    {
                        "score": {
                            "objective": "square",
                            "name": "@e[tag=square:helper]"
                        }
                    }
                ]
            },
            {
                "rawtext": [
                    {
                        "text": "000"
                    },
                    {
                        "score": {
                            "objective": "square",
                            "name": "@e[tag=square:helper]"
                        }
                    }
                ]
            },
            {
                "translate": "%%3",
                "with": {
                    "rawtext": [
                        {
                            "selector": "@e[tag=square:helper,scores={square=10..99}]"
                        },
                        {
                            "selector": "@e[tag=square:helper,scores={square=1..99}]"
                        },
                        {
                            "rawtext": [
                                {
                                    "text": "0000"
                                },
                                {
                                    "score": {
                                        "objective": "square",
                                        "name": "@e[tag=square:helper]"
                                    }
                                }
                            ]
                        },
                        {
                            "rawtext": [
                                {
                                    "text": "00000"
                                },
                                {
                                    "score": {
                                        "objective": "square",
                                        "name": "@e[tag=square:helper]"
                                    }
                                }
                            ]
                        },
                        {
                            "rawtext": [
                                {
                                    "score": {
                                        "objective": "square",
                                        "name": "@e[tag=square:helper]"
                                    }
                                }
                            ]
                        }
                    ]
                }
            }
        ]
    }
}
```

很显然这是非常复杂的写法，并且非常难以阅读。<br/>
然而，上面的逻辑实际上可以被简化为这样的伪代码。

```python
if {func, game.has_tag('@s', 'square:helper')}:
    number = {score, '@s', 'square'}
    if number >= 100000:
        return str(number)
    elif number >= 10000:
        return '0' + str(number)
    elif number >= 1000:
        return '00' + str(number)
    elif number >= 100:
        return '000' + str(number)
    elif number >= 10:
        return '0000' + str(number)
    elif number >= 1:
        return '00000' + str(number)
    fi
fi

return '000000'
```

另外，如果你有一些数学头脑，<br/>
那么它还可以被继续简化为下面的形式。
```python
if {func, game.has_tag('@s', 'square:helper')}:
    number = {score, '@s', 'square'}
    if number > 0:
        log_ans = {func, math.log(number, 10)}
        log_ans = int(log_ans)
        return '0'*(5-log_ans) + str(number)
    fi
fi

return '000000'
```


### 结论
基于上面给出的例子，我们可以很明显的看出文本组件的局限性。<br/>
因此，本项目希望提供一种方式，摆脱文本组件的复杂写法。<br/>
即，通过提供一种具备可编程性的编程语言来替代原生的文本组件。



## 编程语法
### 概述
目前支持的数据类型如下。
- 整数
- 布尔值
- 浮点数
- 字符串

目前支持的基本操作如下。
- 表达式运算
- 变量赋值
- 代码返回值

支持的代码块分别如下。
- 条件代码块
- 循环代码块


### 基本数据类型
#### 整数
> 诸如 `1, 2, 3` 等不带有小数点的数字。

#### 布尔值
> 表示真或假（是或否）两种状态的数据。<br/>
> 真（是）采用 `True` 表示，<br/>
> 假（否）采用 `False` 表示。

#### 浮点数
> 区别于整数，浮点数指代那些具有小数点的数字，也就是小数。<br/>
> 例如 `2.3, 5.20, 1.0, 2.00000` 等。

#### 字符串
> 由各种文字和符号按顺序组合的串，并且用单引号进行包裹。<br/>
> 
> 下面给出了一些字符串的示例。
> - `'你好'`
> - `'1+1=2 √'`
> - `'你今天吃早饭了吗?'`
>
> 如果不使用单引号包裹字符串，则可能会被视为整数或浮点数。<br/>
> 例如 `2` 会被视为整数 2。只有 `'2'` 才会被视为字符串的 2。
>
> 字符串内允许使用转义符号。<br/>
> 例如，如果希望在字符串内使用单引号，可以考虑使用这样的写法。<br/>
> ```'你好, 你知道 \'Peter\' 叫什么吗？'```
> 这种写法等价于 `你好, 你知道 'Peter' 叫什么吗？`。
>
> 应特别说明的是，诸如 `\u000A` 的形式在现阶段不支持被转义。<br/>
> 目前仅支持对反斜杠后的 `1` 个字符进行转义。


### 逻辑运算
逻辑运算用于计算真假。<br/>
下面列出了目前支持的逻辑运算符，相应的示例和解释。<br/>
应注意的是，逻辑运算的结果是个布尔值，并且参与逻辑运算的也应该是布尔值。

| 运算符 | 用途         | 示例                  | 解释                                                                                                |
| ------ | ------------ | --------------------- | --------------------------------------------------------------------------------------------------- |
| and    | 与运算       | A and B and ... and N | A、B、...、N 是否同时为真。<br/>如果是这样的，则计算结果为真，否则为假。                            |
| or     | 或运算       | A or B or ... or N    | A、B、...、N 是否有一个为真。<br/>如果是这样的，则计算结果为真，否则为假。                          |
| not    | 取反运算     | not A                 | 反转布尔值 A 的值。<br/>这意味着真将变为假，假将变为真。                                            |
| in     | 成员检查运算 | A in B                | 检查 A 是否在 B 中。<br/>如果是这样的，则计算结果为真，否则为假。<br/>如检查 'AB' 是否在 'ABC' 中。 |

特别地，上面的与运算和或运算会在可以断言结果真假时停止处理。<br/>
这意味着如果与运算的过程中，如果已经出现假，则整个运算为假；<br/>
在或运算的过程中，如果已经出现真，则整个运算为真。

另外，上面几个运算符的优先级，从高到低分别如下。
- 成员检查运算 (in)
- 取反运算 (not)
- 与运算 (and)
- 或运算 (or)


### 数学计算
数学计算是常规的数学表达式。<br/>
下面是支持的数学运算符及相应的示例和解释。

| 运算符 | 用途   | 示例                | 解释                                                           |
| ------ | ------ | ------------------- | -------------------------------------------------------------- |
| +      | 加运算 | A + B + C + ... + N | 计算 A 到 N 的和                                               |
| -      | 减运算 | A - B - C - ... - N | 计算 A 减去 B，然后再减去 C，然后一直操作下去直到减去 N 的结果 |
| *      | 乘运算 | A * B * C * ... * N | 计算 A 乘以 B 乘以 C，直到乘以 N 的结果                        |
| /      | 除运算 | A / B / C / ... / N | 计算 A 除以 B，然后再除以 C，然后一直操作下去直到除 N 的结果   |

上面给出的示例的空格不是必须的，仅是美观用途。<br/>
另外，上面几个运算符的优先级与实际的四则运算的优先级是相同的。


### 括号
括号可以改变运算表达式时的顺序。<br/>
下面给出的一些例子可以帮助理解。

#### 示例一
> 该数学运算先计算 10 乘以 3 的值，然后将乘出来的结果与 1 相加。<br/>
> 因此，它的结果将是 `31`。
> ```python
> 1+(10*3)
> ```

#### 示例二
> 该表达式先计算 `8*8==60 and 0*0==0` 的值。
> 
> 很显然 8 乘以 8 是 64，<br/>
> 所以 `8*8==60 and 0*0==0` 的结果为假。
>
> 于是，表达式化为 `4*6/12==2 or False`。<br/>
> 很显然 4 乘以 6 再除以 12 是 2，所以 `4*6/12==2` 为真。
> 
> 因此 `4*6/12==2 or False` 即 `True or False` 为真。<br/>
> 因此，整个表达式的结果是真，也就是 `True`。
> ```python
> 4*6/12==2 or (8*8==60 and 0*0==0)
> ```


### 表达式运算
表达式是一串求值结果为已支持数据类型之一的单行代码。<br/>
这串单行代码可以包含上面提到的逻辑运算或数学计算。<br/>
它可以用于数学计算，或者逻辑判断，或者字符串拼接等。<br/>
下面列出的例子有助于帮助你的理解。

#### 示例一
> 该表达式将计算 1+1 的结果，很显然是 `2`。
> ```python
> 1+1
> ```

#### 示例二
> 该表达式将判断 1+1 是否为 2。<br/>
> 很显然这是成立的，所以求值结果是 `True`。
> ```python
> 1+1==2
> ```

#### 示例三
> 该表达式将判断 1+1=2 并且 2+2=4 是否同时成立。<br/>
> 很显然这是成立的，所以求值结果是 `True`。
> ```python
> 1+1==2 and 2+2==4
> ```

#### 示例四
> 该表达式将判断 1+1=2 并且 2+2=4 是否同时成立。<br/>
> 很显然这是成立的，所以求值结果是 `True`。
> ```python
> 1+1==2 and 2+2==4
> ```

#### 示例五
> 该表达式将判断 1+1=2 并且 2+2=4 并且 9+9==0 是否同时成立。<br/>
> 很显然 9+9 为 18 而不是 0，所以求值结果是 `False`。
> ```python
> 1+1==2 and 2+2==4 and 9+9==0 
> ```

#### 示例六
> 由于与运算（and）的优先级比或运算（or）的更高，<br/>
> 因此它将先判断 2+2=4 并且 9+9=0 是否成立。<br/>
> 很显然这是不成立的，所以 `2+2==4 and 9+9==0` 为假。
>
> 然后，表达式化为了 `1+1==0 or False`。<br/>
> 进而化为 `False or False`，因为 1+1 不为 0。
> 
> 所以，整个表达式的求值结果是假，也就是 `False`。
> ```python
> 1+1==0 or 2+2==4 and 9+9==0 
> ```

#### 示例七
> 它将首先检查 1+1=2 是否正确。<br/>
> 很显然这是正确的，所以表达式化为 `True or 0/0==0`。
>
> 你可以观察到还有一个是 `0/0==0`，这是不正确的运算，<br/>
> 但由于或运算中已经存在一个为真了，所以整个或运算为真。
>
> 因此对该表达式的求值结果是 `True`。
> ```python
> 1+1==2 or 0/0==0
> ```
>
> 具体来说，解释器会按顺序进行逻辑运算。<br/>
> 如果在某次运算时，出现了一个真值，则或运算的结果是真，而无论剩余的部分是否正确；<br/>
> 如果出现的是一个假值，则与运算的结果是假，而无论剩余的部分是否正确。
> 
> 类似的例子是与运算的，它的求值结果是 `False`。
> ```python
> 1+1==0 and 0/0==0
> ```