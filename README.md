# Form Python AST
## 目录
- [Form Python AST](#form-python-ast)
  - [目录](#目录)
  - [概述](#概述)
  - [目的](#目的)
    - [综述](#综述)
    - [例子](#例子)
    - [结论](#结论)
  - [编程语法](#编程语法)
    - [概述](#概述-1)
    - [基本数据类型](#基本数据类型)
      - [整数](#整数)
      - [布尔值](#布尔值)
      - [浮点数](#浮点数)
      - [字符串](#字符串)
    - [逻辑运算](#逻辑运算)
    - [数学计算](#数学计算)
    - [比较运算](#比较运算)
    - [解析目标选择器](#解析目标选择器)
      - [示例一](#示例一)
      - [示例二](#示例二)
      - [示例三](#示例三)
      - [示例四](#示例四)
      - [示例四](#示例四-1)
      - [示例四](#示例四-2)
    - [获取分数](#获取分数)
      - [示例一](#示例一-1)
      - [示例二](#示例二-1)
      - [示例三](#示例三-1)
    - [执行命令](#执行命令)
      - [示例一](#示例一-2)
      - [示例二](#示例二-2)
    - [查询玩家提交的表单的响应](#查询玩家提交的表单的响应)
    - [括号](#括号)
      - [示例一](#示例一-3)
      - [示例二](#示例二-3)
    - [表达式运算](#表达式运算)
      - [示例一](#示例一-4)
      - [示例二](#示例二-4)
      - [示例三](#示例三-2)
      - [示例四](#示例四-3)
      - [示例五](#示例五)
      - [示例六](#示例六)
      - [示例七](#示例七)





## 概述
**Form Python AST** 是基于纯 **Python** 开发的 **AST** 抽象语法树解析器。<br/>
它在形式上定义了一种新的编程语言，并提供了相应的源代码解析、编译和运行的功能。



## 目的
### 综述
在 **Minecraft** 基岩版中，人们通过[文本组件](https://zh.minecraft.wiki/w/%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6#%E5%9F%BA%E5%B2%A9%E7%89%88)来显示标题文本和聊天栏信息。<br/>
文本组件是由 `rawtext` 包裹的列表，目前被广泛用于 `titleraw` 和 `tellraw` 命令。

在基岩版中，文本组件可以用于翻译本地化键名、解析实体名和分数。<br/>
在实践中，它也具有一定的条件判断功能，从而使得单命令方块彩虹条等实践成为现实。

然而，原有的条件判断不是被特别设计的，它更像是一个特性。<br/>
因此，通过利用该特性来处理文本显示实际上并不方便。

具体来说，文本组件在单个条件判断的块中，它只能支持有限次条件测试。<br/>
对于更多的条件测试，则必须通过嵌套文本组件，或展平（平铺）多个条件判断块。


### 例子
例如，下方的这个文本组件用于补全分数的前导零，<br>
并且只会处理具有标签 **square:helper** 的实体。

保证该实体只有 `1` 个，并且其在 `square` 上的分数是非负整数。<br/>
那么，它会这样处理该实体在 `square` 的分数，然后把处理的结果给显示出来。
- 233333 => 233333
- 23333 => 023333
- 2333 => 002333
- 233 => 000233
- 23 => 000023
- 2 => 000002

下面是对应的 **JSON** 文本组件。
```json
{
    "translate": "%%5",
    "with": {
        "rawtext": [
            {
                "selector": "@e[tag=square:helper,scores={square=10000..99999}]"
            },
            {
                "selector": "@e[tag=square:helper,scores={square=!..999,square=!100000..}]"
            },
            {
                "selector": "@e[tag=square:helper,scores={square=!..99,square=!100000..}]"
            },
            {
                "selector": "@e[tag=square:helper,scores={square=..999999}]"
            },
            {
                "rawtext": [
                    {
                        "text": "0"
                    },
                    {
                        "score": {
                            "objective": "square",
                            "name": "@e[tag=square:helper]"
                        }
                    }
                ]
            },
            {
                "rawtext": [
                    {
                        "text": "00"
                    },
                    {
                        "score": {
                            "objective": "square",
                            "name": "@e[tag=square:helper]"
                        }
                    }
                ]
            },
            {
                "rawtext": [
                    {
                        "text": "000"
                    },
                    {
                        "score": {
                            "objective": "square",
                            "name": "@e[tag=square:helper]"
                        }
                    }
                ]
            },
            {
                "translate": "%%3",
                "with": {
                    "rawtext": [
                        {
                            "selector": "@e[tag=square:helper,scores={square=10..99}]"
                        },
                        {
                            "selector": "@e[tag=square:helper,scores={square=1..99}]"
                        },
                        {
                            "rawtext": [
                                {
                                    "text": "0000"
                                },
                                {
                                    "score": {
                                        "objective": "square",
                                        "name": "@e[tag=square:helper]"
                                    }
                                }
                            ]
                        },
                        {
                            "rawtext": [
                                {
                                    "text": "00000"
                                },
                                {
                                    "score": {
                                        "objective": "square",
                                        "name": "@e[tag=square:helper]"
                                    }
                                }
                            ]
                        },
                        {
                            "rawtext": [
                                {
                                    "score": {
                                        "objective": "square",
                                        "name": "@e[tag=square:helper]"
                                    }
                                }
                            ]
                        }
                    ]
                }
            }
        ]
    }
}
```

很显然这是非常复杂的写法，并且非常难以阅读。<br/>
然而，上面的逻辑实际上可以被简化为这样的伪代码。

```python
if {func, game.has_tag('@s', 'square:helper')}:
    number = {score, '@s', 'square'}
    if number >= 100000:
        return str(number)
    elif number >= 10000:
        return '0' + str(number)
    elif number >= 1000:
        return '00' + str(number)
    elif number >= 100:
        return '000' + str(number)
    elif number >= 10:
        return '0000' + str(number)
    elif number >= 1:
        return '00000' + str(number)
    fi
fi

return '000000'
```

另外，如果你有一些数学头脑，<br/>
那么它还可以被继续简化为下面的形式。
```python
if {func, game.has_tag('@s', 'square:helper')}:
    number = {score, '@s', 'square'}
    if number > 0:
        log_ans = {func, math.log(number, 10)}
        log_ans = int(log_ans)
        return '0'*(5-log_ans) + str(number)
    fi
fi

return '000000'
```


### 结论
基于上面给出的例子，我们可以很明显的看出文本组件的局限性。<br/>
因此，本项目希望提供一种方式，摆脱文本组件的复杂写法。<br/>
即，通过提供一种具备可编程性的编程语言来替代原生的文本组件。



## 编程语法
### 概述
目前支持的数据类型如下。
- 整数
- 布尔值
- 浮点数
- 字符串

目前支持的基本操作如下。
- 表达式运算
- 变量赋值
- 代码返回值

支持的代码块分别如下。
- 条件代码块
- 循环代码块


### 基本数据类型
#### 整数
> 诸如 `1, 2, 3` 等不带有小数点的数字。

#### 布尔值
> 表示真或假（是或否）两种状态的数据。<br/>
> 真（是）采用 `True` 表示，<br/>
> 假（否）采用 `False` 表示。

#### 浮点数
> 区别于整数，浮点数指代那些具有小数点的数字，也就是小数。<br/>
> 例如 `2.3, 5.20, 1.0, 2.00000` 等。

#### 字符串
> 由各种文字和符号按顺序组合的串，并且用单引号 `'` 进行包裹。<br/>
> 
> 下面给出了一些字符串的示例。
> - `'你好'`
> - `'1+1=2 √'`
> - `'你今天吃早饭了吗?'`
>
> 如果不使用单引号包裹字符串，则可能会被视为整数或浮点数。<br/>
> 例如 `2` 会被视为整数 2。只有 `'2'` 才会被视为字符串的 2。
>
> 字符串内允许使用转义符号。<br/>
> 例如，如果希望在字符串内使用单引号，可以考虑使用这样的写法。<br/>
> ```python
> '你好, 你知道 \'Peter\' 叫什么吗？'
> ```
> 这种写法等价于下面的形式。
> ```python
> 你好, 你知道 'Peter' 叫什么吗？
> ```
>
> 应特别说明的是，诸如 `\u000A` 的形式在现阶段不支持被转义。<br/>
> 目前仅支持对反斜杠后的 `1` 个字符进行转义。
> 
> 下面列出了目前支持的转义规则。
> | 转义符 | 用法 | 使用后得到的字符 |
> | ------ | ---- | ---------------- |
> | n      | \n   | 换行             |
> | \      | \\\\ | 反斜杠 `\`       |
> | '      | \\'  | 单引号 `'`       |
> | "      | \\"  | 双引号 `"`       |
> 
> 在本编程语言中，只有单引号 `'` 包围的字符被视作字符串。<br/>
> 但您很可能将源代码写在命令方块中，并用双引号 `"` 包围源代码。<br/>
> 
> 这是因为，命令方块中的字符串用双引号 `"` 包裹，<br/>
> 并且命令方块除了换行以外，也基本上遵循上面的转义规则。
>
> 因此，上面的 Peter 例子就需要改写为下面的形式。<br/>
> 在该形式中，整个字符串被外围的双引号包裹。
> ```python
> "'你好, 你知道 \\'Peter\\' 叫什么吗？'"
> ```
> 这个写法在被命令方块解析后将得到里层的，由单引号包裹的字符串，<br/>
> 也就是下面你看到的这个字符串。你可以很容易发现它跟原来的字符串等价。
> ```python
> '你好, 你知道 \'Peter\' 叫什么吗？'
> ```


### 逻辑运算
逻辑运算用于计算真假。<br/>
下面列出了目前支持的逻辑运算符，相应的示例和解释。<br/>

应注意的是，逻辑运算的结果是个布尔值，并且参与逻辑运算的所有事物也应是布尔值。<br/>
如果参与逻辑运算的不是布尔值，而是其他数据类型对应的事物，则运算结果是不确定的。

| 运算符 | 用途         | 示例                  | 解释                                                                                                |
| ------ | ------------ | --------------------- | --------------------------------------------------------------------------------------------------- |
| and    | 与运算       | A and B and ... and N | A、B、...、N 是否同时为真。<br/>如果是这样的，则计算结果为真，否则为假。                            |
| or     | 或运算       | A or B or ... or N    | A、B、...、N 是否有一个为真。<br/>如果是这样的，则计算结果为真，否则为假。                          |
| not    | 取反运算     | not A                 | 反转布尔值 A 的值。<br/>这意味着真将变为假，假将变为真。                                            |
| in     | 成员检查运算 | A in B                | 检查 A 是否在 B 中。<br/>如果是这样的，则计算结果为真，否则为假。<br/>如检查 'AB' 是否在 'ABC' 中。 |

特别地，上面的与运算和或运算会在可以断言结果真假时停止处理。<br/>
这意味着如果与运算的过程中，如果已经出现假，则整个运算为假；<br/>
在或运算的过程中，如果已经出现真，则整个运算为真。

另外，上面几个运算符的优先级，从高到低分别如下。
- 成员检查运算 (in)
- 取反运算 (not)
- 与运算 (and)
- 或运算 (or)


### 数学计算
数学计算是常规的数学表达式。<br/>
下面是支持的数学运算符及相应的示例和解释。

| 运算符 | 用途   | 示例                | 解释                                                           | 备注                                         |
| ------ | ------ | ------------------- | -------------------------------------------------------------- | -------------------------------------------- |
| +      | 加运算 | A + B + C + ... + N | 计算 A 到 N 的和                                               | 如果 A 到 N 中有一个是浮点数，则结果为浮点数 |
| -      | 减运算 | A - B - C - ... - N | 计算 A 减去 B，然后再减去 C，然后一直操作下去直到减去 N 的结果 | 如果 A 到 N 中有一个是浮点数，则结果为浮点数 |
| *      | 乘运算 | A * B * C * ... * N | 计算 A 乘以 B 乘以 C，直到乘以 N 的结果                        | 如果 A 到 N 中有一个是浮点数，则结果为浮点数 |
| /      | 除运算 | A / B / C / ... / N | 计算 A 除以 B，然后再除以 C，然后一直操作下去直到除以 N 的结果 | 结果一定是浮点数                             |

上面给出的示例的空格不是必须的，仅是美观用途。<br/>
另外，上面几个运算符的优先级与实际的四则运算的优先级是相同的。


### 比较运算
比较运算可以用于字符串和数字，并且确保所有比较运算的结果都是布尔值。<br/>
下面是目前已经支持的比较运算，以及相应的示例和解释。<br/>
注意，下方给出的示例的空格不是必须的，仅是美观用途。

| 运算符 | 用途               | 示例   | 解释                                                |
| ------ | ------------------ | ------ | --------------------------------------------------- |
| >      | 检查是否大于       | A > B  | 如果 A 大于 B，则计算结果是真，否则是假             |
| <      | 检查是否小于       | A < B  | 如果 A 小于于 B，则计算结果是真，否则是假           |
| >=     | 检查是否大于或等于 | A >= B | 如果 A 大于 B 或 A 等于 B，则计算结果是真，否则是假 |
| <=     | 检查是否小于或等于 | A <= B | 如果 A 小于 B 或 A 等于 B，则计算结果是真，否则为假 |
| ==     | 检查是否等于       | A == B | 如果 A 等于 B，则计算结果是真，否则为假             |
| !=     | 检查是否不等于     | A != B | 如果 A 不等于 B，则计算结果是真，否则为假           |

另外，任何比较运算都不能连用，例如下面的使用方法是错误的。
```python
1 < 10 < 100
```
必须改写为
```python
1 < 10 and 10 < 100
```
在部分情况下，连用比较运算不会产生报错，但它的运算结果是不确定的。


### 解析目标选择器
要将目标选择器解析为对应的实体名，使用下方的 **Selector** 语句。<br/>

```
{selector, <target: str>}
```

`<target: str>` 指代一个目标选择器，并且应是一个字符串。<br/>
另外，**Selector** 语句所得的结果亦是一个字符串。

若 `<target: str>` 指示的目标选择器没有与之对应的实体，<br/>
则该语句的执行结果将是一个空的字符串。

若 `<target: str>` 指代多个实体，则这些实体的名字都将被放入执行结果中。<br/>
例如，如果 `<target: str>` 指代的实体是 Steve、Alex 和 233，则该语句的执行结果如下。
```
Steve, Alex, 233
```

下面给出了一些示例。

#### 示例一
> 解析 `@p` 为实体名。
> ```python
> {selector, '@p'}
> ```

#### 示例二
> 解析 `@e[type=zombine]` 为实体名。
> ```python
> {selector, '@e[type=zombine]'}
> ```

#### 示例三
> 解析 `@a[tag=aabbcc,r=3]` 为实体名。
> ```python
> {selector, '@a[tag=aabbcc,r=3]'}
> ```

#### 示例四
> 解析 `@a[tag=aabbcc,r=3]` 为实体名。
> ```python
> {selector, '@a[tag=aabbcc,r=3]'}
> ```

#### 示例四
> 解析 `Alex` 为实体名。<br/>
> 在这个例子中，`Alex` 指代一个名字叫做 `Alex` 的玩家。
> ```python
> {selector, 'Alex'}
> ```

#### 示例四
> 解析 `@e[name="233"]` 为实体名。
> ```python
> {selector, '@e[name="233"]'}
> ```


### 获取分数
要获取分数，使用下方的 **Score** 语句。

```
{score, <player: str>, <scoreboard: str>}
```

该语句中 `<target: str>` 和 `<scoreboard: str>` 均为字符串。<br/>
但 **Score** 语句的执行结果是一个整数，因为分数只可能是整数。

`<target: str>` 指代指向玩家的目标选择器。<br/>
`<scoreboard: str>` 指代相应分数所在的记分板名。

若想指代命令执行者本身，`<target: str>` 也可以置为通配符 `*`。<br/>
在这种情况下，`<target: str>` 填写为 `@s` 或 `*` 都是等效的。<br/>
最后，若 `<target: str>` 未指向一个玩家，或相应的玩家不存在，则获取到的分数为 0。

下面给出了一些示例。

#### 示例一
> 获取 `@s` 在记分板 `coin` 的分数。
> ```python
> {score, '@s', 'coin'}
> ```

#### 示例二
> 获取 `@a[r=10]` 在记分板 `abc` 的分数。
> ```python
> {score, '@a[r=10]', 'abc'}
> ```

#### 示例三
> 获取 `233` 在记分板 `'cd'` 的分数。<br/>
> 在这个例子中，`233` 指代一个名字叫做 `233` 的玩家。
> ```python
> {score, '233', '\'cd\''}
> ```


### 执行命令
要在当前命令执行环境（命令执行上下文）中执行命令，使用下方的 **Command** 语句。

```
{command, <commandLine: str>}
```

该语句中 `<commandLine: str>` 是一个字符串。<br/>
**Command** 语句的执行结果是一个整数，指示命令的成功次数。<br/>
就目前而言，受制于网易接口，成功次数只可能是 0 或 1。

下面给出了一些示例。

#### 示例一
> 在对应的命令执行环境中执行指令 `say hello`。
> ```python
> {command, 'say hello'}
> ```

#### 示例二
> 在对应的命令执行环境中执行指令 `execute as @s at @s run say hello`。
> ```python
> {command, 'execute as @s at @s run say hello'}
> ```


### 查询玩家提交的表单的响应
...


### 括号
括号可以改变表达式的运算顺序。<br/>
下面给出的一些例子可以帮助理解。

#### 示例一
> 该数学运算先计算 10 乘以 3 的值，然后将乘出来的结果与 1 相加。<br/>
> 因此，它的结果将是 `31`。
> ```python
> 1+(10*3)
> ```

#### 示例二
> 该表达式先计算 `8*8==60 and 0*0==0` 的值。
> 
> 很显然 8 乘以 8 是 64，<br/>
> 所以 `8*8==60 and 0*0==0` 的结果为假。
>
> 于是，表达式化为 `4*6/12==2 or False`。<br/>
> 很显然 4 乘以 6 再除以 12 是 2，所以 `4*6/12==2` 为真。
> 
> 因此 `4*6/12==2 or False` 即 `True or False` 为真。<br/>
> 因此，整个表达式的结果是真，也就是 `True`。
> ```python
> 4*6/12==2 or (8*8==60 and 0*0==0)
> ```


### 表达式运算
表达式是一串求值结果为已支持数据类型之一的单行代码。<br/>
这串单行代码可以包含上面提到的逻辑运算或数学计算。<br/>
它可以用于数学计算，或者逻辑判断，或者字符串拼接等。<br/>
下面列出的例子有助于帮助你的理解。

#### 示例一
> 该表达式将计算 1+1 的结果，很显然是 `2`。
> ```python
> 1+1
> ```

#### 示例二
> 该表达式将判断 1+1 是否为 2。<br/>
> 很显然这是成立的，所以求值结果是 `True`。
> ```python
> 1+1==2
> ```

#### 示例三
> 该表达式将判断 1+1=2 并且 2+2=4 是否同时成立。<br/>
> 很显然这是成立的，所以求值结果是 `True`。
> ```python
> 1+1==2 and 2+2==4
> ```

#### 示例四
> 该表达式将判断 1+1=2 并且 2+2=4 是否同时成立。<br/>
> 很显然这是成立的，所以求值结果是 `True`。
> ```python
> 1+1==2 and 2+2==4
> ```

#### 示例五
> 该表达式将判断 1+1=2 并且 2+2=4 并且 9+9==0 是否同时成立。<br/>
> 很显然 9+9 为 18 而不是 0，所以求值结果是 `False`。
> ```python
> 1+1==2 and 2+2==4 and 9+9==0 
> ```

#### 示例六
> 由于与运算（and）的优先级比或运算（or）的更高，<br/>
> 因此它将先判断 2+2=4 并且 9+9=0 是否成立。<br/>
> 很显然这是不成立的，所以 `2+2==4 and 9+9==0` 为假。
>
> 然后，表达式化为了 `1+1==0 or False`。<br/>
> 进而化为 `False or False`，因为 1+1 不为 0。
> 
> 所以，整个表达式的求值结果是假，也就是 `False`。
> ```python
> 1+1==0 or 2+2==4 and 9+9==0 
> ```

#### 示例七
> 它将首先检查 1+1=2 是否正确。<br/>
> 很显然这是正确的，所以表达式化为 `True or 0/0==0`。
>
> 你可以观察到还有一个是 `0/0==0`，这是不正确的运算，<br/>
> 但由于或运算中已经存在一个为真了，所以整个或运算为真。
>
> 因此对该表达式的求值结果是 `True`。
> ```python
> 1+1==2 or 0/0==0
> ```
>
> 具体来说，解释器会按顺序进行逻辑运算。<br/>
> 如果在某次运算时，出现了一个真值，则或运算的结果是真，而无论剩余的部分是否正确；<br/>
> 如果出现的是一个假值，则与运算的结果是假，而无论剩余的部分是否正确。
> 
> 类似的例子是与运算的，它的求值结果是 `False`。
> ```python
> 1+1==0 and 0/0==0
> ```