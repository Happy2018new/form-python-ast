# 目录
- [目录](#目录)
- [变量、赋值语句](#变量赋值语句)
  - [概述](#概述)
  - [示例一](#示例一)
  - [示例二](#示例二)
  - [示例三](#示例三)
  - [示例四](#示例四)
  - [示例五](#示例五)
  - [示例六](#示例六)
  - [示例七](#示例七)
  - [示例八](#示例八)
  - [示例九](#示例九)
  - [注意事项](#注意事项)
- [条件语句](#条件语句)
  - [概述](#概述-1)
  - [示例一](#示例一-1)
  - [示例二](#示例二-1)





# 变量、赋值语句
## 概述
**赋值语句**用于设置**变量**储存的值。

**变量**类似于记分项，但不局限于储存分数，它可以储存所有**基本数据类型**允许的值，即整数、布尔值、浮点数和字符串。<br/>
**赋值语句**则类似于记分板设置分数的指令，该语句用于将**变量**储存的值设置为指定的整数、布尔值、浮点数或字符串。

赋值语句的语法如下。
```python
变量名 = 表达式
```

这意味着等号的左侧是**变量名**，等号的右侧是**表达式**。<br/>
**变量名**指的是变量的名字，它类似于记分板中虚拟玩家的名字。

在运行代码时，等号右侧的**表达式**会被求值，得到一个整数、布尔值、浮点数或字符串。<br/>
然后，把这个求值结果保存到**变量名**指向的变量中。<br/>
我们把这样的先求值，再将求值结果保存到**变量**的操作称为**赋值操作**。

注意，在所有情况下，您都只能通过**变量名**来获取或更新变量的值。<br/>
另外，在下面给出的示例中，大多数空格都不是必须的，这只是为了让代码更美观。



## 示例一
将变量 `a` 的值设置为整数 `1`。
```python
a = 1
```



## 示例二
首先将变量 `a` 的值设置为整数 1。<br/>
然后将变量 `b` 的值设置为 `a` 加 1 的值，也就是 `2`。

另外，您可以发现这实际上是两条赋值语句。<br/>
第一条对变量 `a` 进行赋值，第二条则对变量 `b` 进行赋值。

```python
a = 1
b = a + 1
```



## 示例三
```python
var_a = 0
var_b = +0
var_c = -0
var_d = 1
var_e = +1
var_f = -1

var_g = True
var_h = False

var_i = 0.0
var_j = +0.0
var_k = -0.0
var_l = 1.5
var_m = +1.5
var_n = -1.5

var_o = ''
var_p = '我想玩电脑'
```

在执行上面的代码后，对应变量储存了以下的数据。

| 变量名 | 储存的数据 | 储存的数据的数据类型 |
| ------ | ---------- | -------------------- |
| var_a  | 0          | 整数                 |
| var_b  | 0          | 整数                 |
| var_c  | 0          | 整数                 |
| var_d  | 1          | 整数                 |
| var_e  | 1          | 整数                 |
| var_f  | -1         | 整数                 |

| 变量名 | 储存的数据 | 储存的数据的数据类型 |
| ------ | ---------- | -------------------- |
| var_g  | True       | 布尔值               |
| var_h  | False      | 布尔值               |

| 变量名 | 储存的数据 | 储存的数据的数据类型 |
| ------ | ---------- | -------------------- |
| var_i  | 0.0        | 浮点数               |
| var_j  | 0.0        | 浮点数               |
| var_k  | 0.0        | 浮点数               |
| var_l  | 1.5        | 浮点数               |
| var_m  | 1.5        | 浮点数               |
| var_n  | -1.5       | 浮点数               |

| 变量名 | 储存的数据   | 储存的数据的数据类型 |
| ------ | ------------ | -------------------- |
| var_o  | ''           | 字符串               |
| var_p  | '我想玩电脑' | 字符串               |



## 示例四
```python
part_a = 'tag=回城'
part_b = 'tag=!op'
scoreboard = '音效分数'
my_score = {score, '@s['+part_a+']', scoreboard}
my_name = {selector, '@s['+part_a+','+part_b+']'}
```

上面的代码首先按顺序赋值了下面几个变量。

| 变量名     | 变量储存的数据 | 变量储存的数据的数据类型 |
| ---------- | -------------- | ------------------------ |
| part_a     | `tag=回城`     | 字符串                   |
| part_b     | `tag=!op`      | 字符串                   |
| scoreboard | `音效分数`     | 字符串                   |

然后，获取 `'@s['+part_a+']'` 在记分板 `scoreboard` 的分数，<br/>
也就是 `@s[tag=回城]` 在记分板 `音效分数` 的分数。<br/>
获取到的这个分数最终将会保存在变量 `my_score` 中。

最后，将 `'@s['+part_a+','+part_b+']'` 指示的实体解析为实体名，<br/>
也就是把 `@s[tag=回城,tag=!op]` 指示的实体解析为实体名。<br/>
解析出的这个实体名最终会保存在变量 `my_name` 中。

另外，您可能发现了我们没有使用下面的写法。
```python
my_score = {score, '@s[tag=回城]', '音效分数'}
my_name = {selector, '@s[tag=回城,tag=!op]'}
```

这意味着 **Score** 和 **Selector** 语句都支持将表达式的求值结果作为字符串。

在上面的例子中，`'@s['+part_a+']'` 和 `'@s['+part_a+','+part_b+']'` 都是表达式，<br/>
并且这两个表达式的求值结果分别是 `'@s[tag=回城]'` 和 `'@s[tag=回城,tag=!op]'`。

| 表达式                    | 求值结果               |
| ------------------------- | ---------------------- |
| '@s['+part_a+']           | '@s[tag=回城]'         |
| @s['+part_a+','+part_b+'] | '@s[tag=回城,tag=!op]' |

实际上，对于所有的语句，您都可以在原本填写 字符串/整数/布尔值/浮点数 的地方填写为表达式。<br/>
在实际运行代码的时候，这些表达式会被求值，然后被传入对应的语句中，如本例中的 **Score** 和 **Selector** 语句。



## 示例五
下面的代码相对于[示例三](#示例三)除了变量名发生了变化以外，其他的功能与[示例三](#示例三)的是完全相同的。
```python
aaa = 'tag=回城'
bbb = 'tag=!op'
ccc = '音效分数'
my_score = {score, '@s['+aaa+']', ccc}
my_name = {selector, '@s['+aaa+','+bbb+']'}
```



## 示例六
下面的代码是[示例三](#示例三)的简化版本，但功能与[示例三](#示例三)的相比，是基本相同的。<br/>
在这个例子中，我们没有像[示例三](#示例三)那样拼接出目标选择器的字符串，而是直接写在代码里。

```python
target_a = '@s[tag=回城]'
target_b = '@s[tag=回城,tag=!op]'
scoreboard = '音效分数'
my_score = {score, target_a, scoreboard}
my_name = {selector, target_b}
```



## 示例七
下面的代码先将变量 `a` 赋值为 1。<br/>
然后，计算 `a+1` 的值（也就是2），并把该值作为 `a` 的新值。<br/>
然后，计算 `a+2` 的值（也就是4），并把该值作为 `a` 的新值。<br/>
最终，变量 `a` 的值将是整数 4。

```python
a = 1
a = a+1
a = a+2
```



## 示例八
下面的代码先将变量 `a` 赋值为 2333。<br/>
然后，计算 `a*a/a` 的值，得到 2333.0，然后将其作为 `a` 的新值。<br/>
最终，变量 `a` 的值将是浮点数 2333.0。

```python
a = 2333
a = a*a/a
```



## 示例九
```python
ak5 = 'pp' in 'pc'
gpt = 2+2>4 or (7+10)/2<0 and int('50') <= 50 or not ak5
clade = not 23 <= 60 or gpt
```

在执行上面的代码后，对应变量储存了以下的数据。

| 变量名 | 储存的数据 | 储存的数据的数据类型 |
| ------ | ---------- | -------------------- |
| ak5    | False      | 布尔值               |
| gpt    | True       | 布尔值               |
| clade  | True       | 布尔值               |



## 注意事项
并非所有的名称都可以作为变量名。

首先，变量名不能以数字开头；<br/>
其次，变量名中不能出现标点符号；<br/>
最后，变量名不能使用该编程语言的保留关键字。

下面列出了本编程语言的所有保留关键字。
- int, bool, str, float
- ref, selector, score, command, func
- return
- if, else, elif, fi
- for, continue, break, rof
- and, or, not, in
- True, False

下面这些例子都是不合法的变量名。
- 233gk5 (变量名以数字开头)
- wo_de_!jie (变量名中包含标点符号)
- command (变量名是保留的关键字)
- True (变量名是保留的关键字)

下面的例子是合法的变量名。
- command_a
- command_b
- True_False
- ref_0

另外，您可能发现部分标点符号可以出现在变量名中。<br/>
这种情况下虽然没有报错，但不保证这样的变量名在未来仍然可以继续有效。





# 条件语句
## 概述
**条件语句**是编程中的一种控制结构，它允许程序根据不同的条件执行不同的代码块。<br/>
简单来说，它让程序依照某种方式来作出决定。因此，这赋予了程序可以作出决定的能力。

在本编程语言中，**条件语句**的语法如下。
```python
if 条件1:
    代码块1
elif 条件2:
    代码块2
elif 条件3:
    代码块3
...
elif 条件N:
    代码块N
else:
    代码块N’
fi
```

首先，`条件1`、`条件2`、...、`条件N` 都是表达式。<br/>
并且，这些表达式的求值结果都应当是一个布尔值。

在代码被运行时，系统从 `条件1` 开始，按顺序地检查每个条件是否是 `True`，直到 `条件N`。<br/>
在发现某个条件为 `True` 时，执行这个条件中的代码块。<br/>

代码块由一个或多个代码构成。在对应条件的代码块被执行完毕后，<br/>
后方所有的条件都不再被检查是否为 `True`，并且这些条件中的代码块都不会被执行。

因此您会发现这实际上是某种分支结构。只有其中一个条件中的代码会被执行。<br/>
特别地，如果所有这些条件都为 `False`，则 `else` 中的代码块 `代码块N’` 会被执行。

例如，在上面的例子中，如果 `条件1` 和 `条件2` 都是假，而 `条件3` 为真，则 `代码块3` 会被执行。<br/>
即便后面有条件是真，由于 `条件3` 已经为真，所以后方的所有条件都不会被处理，并且它们的代码块也不会被执行。

另外，这个写法也是有效的。<br/>
它与上面的区别在于它不存在 `else`，这意味着如果所有条件都是假，则没有代码会被执行。
```python
if 条件1:
    代码块1
elif 条件2:
    代码块2
...
elif 条件N:
    代码块N
fi
```


还有一种写法是不使用 `elif`。<br/>
这个写法指的是当 `条件` 为真时，执行 `代码块1`，否则执行 `代码块2`。
```python
if 条件:
    代码块1
else:
    代码块2
fi
```

还有一种写法是只使用 `if`。<br/>
这个写法指的是当 `条件` 为真时，执行 `代码块`。<br/>
如果它不是真，则什么都不会执行。
```python
if 条件:
    代码块
fi
```

另外，我认为您有必要真正理解 `if, elif` 和 `else` 的中文意思。
| 英文 | 中文释义                              |
| ---- | ------------------------------------- |
| if   | 如果                                  |
| else | 否则                                  |
| elif | else if 的缩写。<br/>代表“否则如果”。 |

也就是说，该编程语言的**条件语句**实际上类似于下面的东西。

```python
如果 条件1:
    ...
否则如果 条件2:
    ...
否则如果 条件3:
    ...
...
否则如果 条件N:
    ...
否则:
    ...
```

另外，您会发现上面的 4 个写法中，每个写法的最后一行都是 `fi`。<br/>
`fi` 实际上用来告诉系统，这一整个**条件语句**已经写完了。

您可以嵌套条件语句，比如下面这个例子。
```python
if 条件1:
    一些代码
    if 条件2:
        一些代码
    elif 条件3:
        一些代码
    fi
    一些代码
elif 条件4:
    一些代码
    if 条件5:
        一些代码
    fi
    一些代码
else:
    一些代码
    if 条件6:
        if 条件7:
            一些代码
        else:
            一些代码
        fi
    fi
    一些代码
fi
```

下面给出的例子可以帮助您进一步理解。



## 示例一
```python
a=0
b=1
c=2

if a==0:
    a=a+20.3
fi

if b>0:
    b=b+1
elif b>0:
    b=b-1
elif b<0:
    b=b-1000
else:
    b=1000
fi

if c==0:
    c=c+10
else:
    c=c-10
fi

k=a*b*c
if k>0:
    k=233
fi
```

---

上面的代码先对变量 `a, b` 和 `c` 进行赋值。

| 变量名 | 储存的数据 | 储存的数据的数据类型 |
| ------ | ---------- | -------------------- |
| a      | 0          | 整数                 |
| b      | 1          | 整数                 |
| c      | 2          | 整数                 |

---

然后进行下面的条件判断。

| 条件 | 当条件成立时执行 |
| ---- | ---------------- |
| a==0 | a=a+20.3         |

很显然 `a` 为 0，因此条件成立，于是 `a` 会被更新为 20.3。

---

然后进行下面的条件判断。

| 条件         | 当条件成立时执行 |
| ------------ | ---------------- |
| b>0 (1)      | b=b+1            |
| b>0 (2)      | b=b-1            |
| b<0          | b=b-1000         |
| 其他所有情况 | b=1000           |

很显然 `b` 大于 0，因此 `b>0 (1)` 成立。<br/>
并且由于条件判断是按顺序的，并且只会命中一个条件，因此只有 `b>0 (1)` 会被命中。<br/>
因而，只有 `b=b+1` 被执行，所以 `b` 会被更新为 2。

---

然后进行下面的条件判断。

| 条件 | 当条件成立时执行 |
| ---- | ---------------- |
| c==0 | c=c+10           |
| 否则 | c=c-10           |

很显然 `c` 等于 0 不成立，因此执行 `否则` 对应的代码，也就是 `c=c-10`。<br/>
然后，变量 `c` 会被更新为 -8。

---

然后执行 `k=a*b*c`，使得变量 `k` 被设置为浮点数 -324.8。

---

然后进行下面的条件判断。

| 条件 | 当条件成立时执行 |
| ---- | ---------------- |
| k>0  | k=233            |

很显然 `k` 是负数，不大于 0，因此条件不成立，所以 `k=233` 不会被执行。

---

最终，在全部代码执行完成后，所有的变量的情况如下。

| 变量名 | 储存的数据 | 储存的数据的数据类型 |
| ------ | ---------- | -------------------- |
| a      | 20.3       | 浮点数               |
| b      | 2          | 整数                 |
| c      | -8         | 整数                 |
| k      | -324.8     | 浮点数               |



## 示例二
```python
time=1000
dinner=25.75
string='hello'

other1=1
other2=10
other3=20

if time > 50*2+899:
    new_str = 'hello2'
    string = string*2 + new_str
else:
    a = 0
    b = 1
    c = 2
fi

if other1 < 0:
    bbc = 0/0
    ggc = string*114514
elif other2 == 10:
    other2 = other2 * 25.25
    other3 = other2 + other3
    temp = '-----'
    string = temp + '/' + string + '/' + str(other3) + '/' + temp
else:
    new_str = 'hello3'
fi

result = str(time) + ' ' + str(dinner) + ' ' + str(string) + ' ' + str(other1+other2+other3)
```

---

上面的代码先对变量 `time, dinner, string, other1, other2` 和 `other3` 进行赋值。

| 变量名 | 储存的数据 | 储存的数据的数据类型 |
| ------ | ---------- | -------------------- |
| time   | 1000       | 整数                 |
| dinner | 25.75      | 小数                 |
| string | 'hello'    | 字符串               |
| other1 | 1          | 整数                 |
| other2 | 10         | 整数                 |
| other3 | 20         | 整数                 |

---

然后进行下面的条件判断。

| 条件            | 当条件成立时执行                                   |
| --------------- | -------------------------------------------------- |
| time > 50*2+899 | new_str = 'hello2'<br/>string = string*2 + new_str |
| 否则            | a = 0<br/>b = 1<br/>c = 2                          |

很显然 50 乘以 2 再加上 899 为 999，它比 time 也就是 1000 更小。<br/>
因此 `否则` 不会被执行，而是执行下面的代码。

```python
new_str = 'hello2'
string = string*2 + new_str
```

于是 `new_str` 被设置为字符串 'hello2'，<br/>
`string` 被更新为字符串 `hellohellohello2`。

---

然后进行下面的条件判断。

| 条件         | 当条件成立时执行                                                                                                                          |
| ------------ | ----------------------------------------------------------------------------------------------------------------------------------------- |
| other1 < 0   | bbc = 0/0<br/>ggc = string*114514                                                                                                         |
| other2 == 10 | other2 = other2 * 25.25<br/>other3 = other2 + other3<br/>temp = '-----'<br/>string = temp + '/' + string + '/' + str(other3) + '/' + temp |
| 其他所有情况 | new_str = 'hello3'                                                                                                                        |

系统首先检查 `other1 < 0` 是否成立。很显然 other 为 1 不小于 0，因此它不成立。<br/>
然后，系统检查 `other2 == 10` 是否成立。很显然 other2 就是 10，因此它成立。

所以，`other2 == 10` 对应的代码块，也就是下面的代码，将会被执行。
```python
other2 = other2 * 25.25
other3 = other2 + other3
temp = '-----'
string = temp + '/' + string + '/' + str(other3) + '/' + temp
```

在执行完成后，截止到目前，所有变量的数据如下。

| 变量名  | 储存的数据                           | 储存的数据的数据类型 |
| ------- | ------------------------------------ | -------------------- |
| time    | 1000                                 | 整数                 |
| dinner  | 25.75                                | 小数                 |
| string  | '-----/hellohellohello2/272.5/-----' | 字符串               |
| other1  | 1                                    | 整数                 |
| other2  | 252.5                                | 浮点数               |
| other3  | 272.5                                | 浮点数               |
| new_str | 'hello2'                             | 字符串               |
| temp    | '-----'                              | 字符串               |

---

最后，执行了该表达式，并将其赋值给变量 `result`。

```python
str(time) + ' ' + str(dinner) + ' ' + str(string) + ' ' + str(other1+other2+other3)
```

这使得 `result` 最终会保存下面这个字符串。

```python
'1000 25.75 -----/hellohellohello2/272.5/----- 526.0'
```

实际上，该表达式先将 `time, dinner, string, other1+other2+other3` 都强制转换为字符串。<br/>
其中，`other1+other2+other3` 指的是将 `other1, other2` 和 `other3` 加起来的结果。

进行强制类型转换的原因是因为字符串只能跟字符串拼接，而不能跟其他数据类型的数据拼接。<br/>
在完成强制类型转换后，再将所有东西彼此拼接，并确保彼此之间由一个空格 `' '` 分隔。
