# 目录
- [目录](#目录)
- [解析目标选择器](#解析目标选择器)
  - [概述](#概述)
  - [示例一](#示例一)
  - [示例二](#示例二)
  - [示例三](#示例三)
  - [示例四](#示例四)
  - [示例五](#示例五)
  - [示例六](#示例六)
- [获取分数](#获取分数)
  - [概述](#概述-1)
  - [示例一](#示例一-1)
  - [示例二](#示例二-1)
  - [示例三](#示例三-1)
- [执行命令](#执行命令)
  - [概述](#概述-2)
  - [示例一](#示例一-2)
  - [示例二](#示例二-2)
- [引用玩家对表单的响应](#引用玩家对表单的响应)
  - [概述](#概述-3)
  - [模态表单](#模态表单)
  - [长表单](#长表单)
  - [信息表单](#信息表单)
- [调用函数](#调用函数)
  - [概述](#概述-4)
  - [示例一](#示例一-3)
  - [示例二](#示例二-3)
  - [示例三](#示例三-2)
  - [示例四](#示例四-1)
  - [小提示](#小提示)
  - [注意事项](#注意事项)





# 解析目标选择器
## 概述
要将目标选择器解析为对应的实体名，使用下方的 **Selector** 语句。<br/>

```
{selector, <target: str>}
```

`<target: str>` 指代一个目标选择器，并且应是一个字符串。<br/>
另外，**Selector** 语句所得的结果亦是一个字符串。

若 `<target: str>` 指示的目标选择器没有与之对应的实体，<br/>
则该语句的执行结果将是一个空的字符串。

若 `<target: str>` 指代多个实体，则这些实体的名字都将被放入执行结果中。<br/>
例如，如果 `<target: str>` 指代的实体是 Steve、Alex 和 233，则该语句的执行结果如下。
```
Steve, Alex, 233
```



## 示例一
解析 `@p` 为实体名。
```python
{selector, '@p'}
```



## 示例二
解析 `@e[type=zombine]` 为实体名。
```python
{selector, '@e[type=zombine]'}
```



## 示例三
解析 `@a[tag=aabbcc,r=3]` 为实体名。
```python
{selector, '@a[tag=aabbcc,r=3]'}
```



## 示例四
解析 `@a[tag=aabbcc,r=3]` 为实体名。
```python
{selector, '@a[tag=aabbcc,r=3]'}
```



## 示例五
解析 `Alex` 为实体名。<br/>
在这个例子中，`Alex` 指代一个名字叫做 `Alex` 的玩家。
```python
{selector, 'Alex'}
```



## 示例六
解析 `@e[name="233"]` 为实体名。
```python
{selector, '@e[name="233"]'}
```





# 获取分数
## 概述
要获取分数，使用下方的 **Score** 语句。

```
{score, <player: str>, <scoreboard: str>}
```

该语句中 `<target: str>` 和 `<scoreboard: str>` 均为字符串。<br/>
但 **Score** 语句的执行结果是一个整数，因为分数只可能是整数。

`<target: str>` 指代指向玩家的目标选择器。<br/>
`<scoreboard: str>` 指代相应分数所在的记分板名。

若想指代命令执行者本身，`<target: str>` 也可以置为通配符 `*`。<br/>
在这种情况下，`<target: str>` 填写为 `@s` 或 `*` 都是等效的。

若 `<target: str>` 未指向一个玩家，或相应的玩家不存在，则获取到的分数为 0。<br/>
若 `<target: str>` 所指向的玩家在目标记分板不存在分数，则获取到的分数为 0。<br/>
若 `<target: str>` 指向多个玩家，则 **Score** 语句将给出所有这些玩家在目标记分板的分数的求和。



## 示例一
获取 `@s` 在记分板 `coin` 的分数。
```python
{score, '@s', 'coin'}
```



## 示例二
获取 `@a[r=10]` 在记分板 `abc` 的分数。
```python
{score, '@a[r=10]', 'abc'}
```



## 示例三
获取 `233` 在记分板 `'cd'` 的分数。<br/>
在这个例子中，`233` 指代一个名字叫做 `233` 的玩家。
```python
{score, '233', '\'cd\''}
```





# 执行命令
## 概述
要在当前命令执行环境（命令执行上下文）中执行命令，使用下方的 **Command** 语句。<br/>

```
{command, <commandLine: str>}
```

该语句中 `<commandLine: str>` 是一个字符串。<br/>
**Command** 语句的执行结果是一个整数，指示命令的成功次数。<br/>

注意，就目前而言，受制于网易接口：
- 命令执行上下文中的命令执行者必须是实体
- 命令执行上下文中的命令执行朝向无法被传递
- 命令成功次数只可能是 0 或 1



## 示例一
在对应的命令执行环境中执行指令 `say hello`。
```python
{command, 'say hello'}
```



## 示例二
在对应的命令执行环境中执行指令 `execute as @s at @s run say hello`。
```python
{command, 'execute as @s at @s run say hello'}
```





# 引用玩家对表单的响应
## 概述
在通过命令方块向玩家展示表单后，玩家可以与表单发生交互，并提交响应。<br/>
因此您需要一个接口来获取玩家针对表单的响应，并根据得到的响应执行对应的处理。



## 模态表单
模态表单由下面列出的元素构成，并且这些元素是有序的。
- 纯文本
- 输入框
- 开关
- 下拉框
- 隐式步进滑块
- 显式步进滑块

玩家可以通过作出下面的操作来填写模态表单。
- 向 `输入框` 填写内容
- 改变 `开关` 开启状态
- 选择 `下拉框` 给出的选项
- 移动 `隐式步进滑块` 或 `显式步进滑块` 中的滑块

玩家填写的内容则会以下面的方式进行存储。<br/>
它们储存的顺序与构成模态表单本身的元素的顺序是一致的。
- 空值 (纯文本)
- 字符串 (输入框)
- 布尔值 (开关)
- 整数 (下拉框)
- 浮点数 (隐式步进滑块)
- 整数 (显式步进滑块)

特别地：
- 对于下拉框和显式步进滑块，`整数` 指的是玩家选中的选项的索引
- 对于隐式步进滑块，`浮点数` 指的是滑块当前最终所在的刻度值

例如，假如我们有这样一个模态表单：
```
纯文本 ABCD、
开关 1（默认关）、
开关 2（默认开）、
隐式步进滑块 1（默认 3.0，最少 1.0，最多 10.0，步长 0.5）、
显式步进滑块 1（内容是 'a', 'b' 和 'c'，默认选择第 2 个）、
输入框 1（默认 'ABC'）
下拉框 1（内容是 '我要吃早饭', '我要吃午饭'，默认选择第 1 个）。
```

则如果用户在不进行任何编辑的情况下，直接提交表单，那么用户的响应如下。
```
空值、
False（关）、
True（开）、
3.0（隐式滑块最终刻度值）、
1（显式滑块最终指向的选项索引）、
'ABC'（用户提供的输入）、
0（下拉框选中的选项的索引）
```

在初步理解模态表单后，您可以通过下面的 **Ref** 语句来获取特定索引上的响应值。

```python
{ref, <dataType: type>, <index: int>}
```

`<index: int>` 指示相应的索引值。<br/>
`<dataType: type>` 指代目标响应值的类型，必须为下列之一。
- int (整数)
- bool (布尔值)
- float (浮点数)
- str (字符串)

具体来说，就上面的例子而言，假设我需要知道 `开关 2` 的结果，<br/>
那么我需要找到 `开关 2` 的位置。它是第三个元素，因此它的索引是 3-1 也就是 2。<br/>
而开关的结果只可能是 `bool`，用 `True` 表示开，用 `False` 表示关。

因此对应的语句如下。
```python
{ref, bool, 2}
```

对于其他部分，对于的语句则如下所示。
```python
开关 1: {ref, bool, 1}
隐式步进滑块 1: {ref, float, 3}
显式步进滑块 1: {ref, int, 4}
输入框 1: {ref, str, 5}
下拉框 1: {ref, int, 6}
```

你不应也无法获取到针对 `纯文本` 的响应。<br/>
因为玩家实际上并不能编辑它们，所以获取它是没有意义的。

另外，如果您填写的数据类型不正确，则会引发错误。<br/>
具体到上面的例子，如果你对 `输入框 1` 使用下面的语句，则将报错。
```python
{ref, bool, 5}
```

这是因为输入框只能输入字符串，<br/>
所以您得到的响应只可能是字符串，而不是布尔值。

这意味着我们实际上会检查获取到的响应值的数据类型是否与您期望的匹配，<br/>
而这么做的目的是为了确保您在编程时减少可能发生的错误。<br/>
这种错误的减少就是通过您手动标注响应值的数据类型进行的。



## 长表单
长表单是由多个按钮组成的，并且这些按钮都是按顺序排列的。<br/>
玩家通过点击长表单中的其中一个按钮来完成对长表单的响应，<br/>
因此玩家对长表单的响应是一个索引，它指向了玩家所点击的按钮。

要获取玩家所点击按钮对应的索引值，使用下面的 **Ref** 语句。
```python
{ref, int, -1}
```

要检查该索引值是否等于 `T`，使用下方的 **Ref** 语句。<br/>
确保下方语句在索引值为 `T` 时返回真，在其他情况下返回假。
```python
{ref, bool, T}
```

与[模态表单](#模态表单)章节所述的一致，上面两个语句中的 `int` 和 `bool` 都指代 `<dataType: type>`。<br/>
对于 `int`，`<dataType: type>` 用于检查 **Ref** 语句执行后所得的结果是否是整数。<br/>
对于 `bool`，`<dataType: type>` 用于检查 **Ref** 语句执行后所得的结果是否是布尔值。



## 信息表单
信息表单用于向玩家显示信息。<br/>
玩家可以通过点击代表“确定”或“取消”的按钮来回应表单。

因此，玩家对信息表单的响应是一个布尔值。<br/>
当布尔值为真时，指示玩家点击指代“确定”的按钮；<br/>
否则，布尔值为假，说明玩家点击了指代“取消”的按钮。

要获取玩家对信息表单的响应，使用下面的 **Ref** 语句。
```python
{ref, bool, -1}
```

要检查玩家点击的是否是代表“确定”的按钮，则使用该语句。<br/>
确保下方语句只在玩家点击了代表“确定”的按钮时返回真，在其他情况下返回假。
```python
{ref, bool, 1}
```

要检查玩家点击的是否是代表“取消”的按钮，则使用该语句。<br/>
确保下方语句只在玩家点击了代表“取消”的按钮时返回真，在其他情况下返回假。
```python
{ref, bool, 0}
```

与[模态表单](#模态表单)章节所述的一致，<br/>
上面三个语句中的 `bool` 都指代 `<dataType: type>`，<br/>
用于检查 **Ref** 语句执行后所得的结果是否是布尔值。





# 调用函数
## 概述
编程语言的提供者可以为该编程语言的用户提供一些函数。<br/>
然后，用户就可以在代码中调用这些函数，从而执行相应的代码逻辑。<br/>

该编程语言的用户可以通过 **Func** 语句来调用函数。
```python
{func, funcName(arg1, arg2, ..., argN)}
```

`funcName` 指代被调用函数的函数名称，<br/>
应直接写出，而不是用单引号 `'` 包裹。

`arg1, arg2, ..., argN` 是传入函数的多个参数。参数从 `arg1` 到 `argN`。<br/>
应特别注意的是，部分函数可能不要求传入参数，此时就可以不用传入任何参数。<br/>
应注意的是，所有传入函数的参数都必须是本编程语言中存在的数据类型。

如果您不理解上面是 `函数`、`调用函数`、`传入函数的参数` 等词汇，<br/>
可以通过查看下方给出的例子来搞明白它们的意思。



## 示例一
调用名为 `math.sqrt` 的函数，并且只传入参数 `4`。<br/>
该函数将对 4 开平方。开方结果即为该语句的执行结果。
```python
{func, math.sqrt(4)}
```



## 示例二
调用名为 `math.pow` 的函数，并且依次传入参数 `2` 和 `3`。<br/>
该函数将计算 2 的 3 次方的结果。这一计算结果即为该语句的执行结果。
```python
{func, math.pow(2, 3)}
```



## 示例三
调用名为 `get_server_name` 的函数，并且不传入任何参数。<br/>
该函数将获取租赁服的名称。该名称即为该语句的执行结果。
```python
{func, get_server_name()}
```



## 示例四
调用名为 `sum` 的函数，并且依次传入参数 `1`、`3`、`5`、`7` 和 `9`。<br/>
该函数将所有传入的参数加起来。这个相加的结果即为该语句的执行结果。

很显然由于传入的参数是 `1`、`3`、`5`、`7` 和 `9`，<br/>
因此该语句的执行结果是 `1+3+5+7+9=25` 即 `25`。

```python
{func, sum(1, 3, 5, 7, 9)}
```



## 小提示
通过上面给出的几个例子，我们可以发现以下这几点。

我们可以发现函数实际上形如“抽象的机器”。<br/>
也就是说，我们并不需要知道如何实现开平方、求幂次、相加等的实际过程，<br/>
我们只需要“调用函数”，就可以得到开评分、求幂次、相加等的计算结果。

函数会根据你所传入的参数来“做事情”，并把做完后的结果“返回”给函数的调用者。<br/>
比如将 `9` 传入开平方的函数，则将得到 3，然后它就会被返回给调用这个开平方函数的人，于是调用者得到了 3。

需要说明的是，函数可以指代任何“抽象的机器”，<br/>
这其中肯定也包括计算棒棒糖的价格等，以及任何可以被程序计算的事，<br/>
而不仅仅局限于上面给出的几个例子。



## 注意事项
上面几个例子中出现的 `math.sqrt, get_server_name` 和 `sum` 函数都只是例子。<br/>
在实际使用该编程语言时，这些函数不一定都全部存在，因为这些函数不是该编程语言本身的特性之一。

该编程语言只是提供了 **Func** 语句，而使用该编程语言的人可以通过该语句调用函数。<br/>
但具体在实际情况下，到底有哪些函数可以进行调用，并不是由本编程语言可以决定的。

这意味着，所有函数都是由相应的外部函数提供者提供的，通常情况下是运行您代码的地方。<br/>
请留意为您提供运行环境的人员留下的文档，里面很有可能记载了在对应的运行环境下，允许调用的函数。